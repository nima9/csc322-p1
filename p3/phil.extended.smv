--
-- CSC 322 Project 3
--
-- Name: Alexander Lambert 
-- Vnum: V00956639
--
-- Name: Carter Cranston
-- Vnum: V01000607
--
-- Name: Nima Mohajeri 
-- Vnum: V00857216
--
--
MODULE main
  
VAR
  chopsticks : array 0..4 of {nobody,0,1,2,3,4}; -- who holds the chopstick.
  --
  -- Philosopher i has chopstick i on left and chopstick
  -- (i + 1) mod 5 on right
  --
  p0 : process philosopher(0,chopsticks[0],chopsticks[1]);
  p1 : process philosopher(1,chopsticks[1],chopsticks[2]);
  p2 : process philosopher(2,chopsticks[2],chopsticks[3]);
  p3 : process philosopher(3,chopsticks[3],chopsticks[4]);
  p4 : process philosopher(4,chopsticks[4],chopsticks[0]);
  
ASSIGN
  --
  -- Initially, all chopsticks are free
  --
  init(chopsticks[0]) := nobody;
  init(chopsticks[1]) := nobody;
  init(chopsticks[2]) := nobody;
  init(chopsticks[3]) := nobody;
  init(chopsticks[4]) := nobody;

-- add specifications here 

-- safety:
SPEC AG!(p1.state = eating & p2.state = eating) -- chopstick 2 can only be used by one philosopher at a time
SPEC AG!(p2.state = eating & p3.state = eating) -- chopstick 3 can only be used by one philosopher at a time
SPEC AG!(p3.state = eating & p4.state = eating) -- chopstick 4 can only be used by one philosopher at a time
SPEC AG!(p4.state = eating & p0.state = eating) -- chopstick 0 can only be used by one philosopher at a time
SPEC AG!(p0.state = eating & p1.state = eating) -- chopstick 1 can only be used by one philosopher at a time
-- liveness
SPEC AG(p0.state = hungry -> AF(p0.state = eating)) -- philosopher 0 can eat eventually, if desired
SPEC AG(p1.state = hungry -> AF(p1.state = eating)) -- philosopher 1 can eat eventually, if desired
SPEC AG(p2.state = hungry -> AF(p2.state = eating)) -- philosopher 2 can eat eventually, if desired
SPEC AG(p3.state = hungry -> AF(p3.state = eating)) -- philosopher 3 can eat eventually, if desired
SPEC AG(p4.state = hungry -> AF(p4.state = eating)) -- philosopher 4 can eat eventually, if desired



-- non-blocking 
SPEC AG(p0.state = thinking -> EX(p0.state = hungry)) -- philosopher 0 can always request to eat (can always get hungry)
SPEC AG(p1.state = thinking -> EX(p1.state = hungry)) -- philosopher 1 can always request to eat (can always get hungry)
SPEC AG(p2.state = thinking -> EX(p2.state = hungry)) -- philosopher 2 can always request to eat (can always get hungry)
SPEC AG(p3.state = thinking -> EX(p3.state = hungry)) -- philosopher 3 can always request to eat (can always get hungry)
SPEC AG(p4.state = thinking -> EX(p4.state = hungry)) -- philosopher 4 can always request to eat (can always get hungry)


-- no strict sequencing (meaning no philosopher can eat before another philosopher has had a chance to eat)
-- philosopher 0 can eat before philosopher 1, 2, 3, 4
SPEC EF (p0.state = eating & EF (A [ p0.state = eating U (!(p0.state = eating) & EF (A [ !(p1.state = eating) U p0.state = eating ]))])) -- philosopher 0 can eat before philosopher 1
SPEC EF (p0.state = eating & EF (A [ p0.state = eating U (!(p0.state = eating) & EF (A [ !(p2.state = eating) U p0.state = eating ]))])) -- philosopher 0 can eat before philosopher 2
SPEC EF (p0.state = eating & EF (A [ p0.state = eating U (!(p0.state = eating) & EF (A [ !(p3.state = eating) U p0.state = eating ]))])) -- philosopher 0 can eat before philosopher 3
SPEC EF (p0.state = eating & EF (A [ p0.state = eating U (!(p0.state = eating) & EF (A [ !(p4.state = eating) U p0.state = eating ]))]))

-- philosopher 1 can eat before philosopher 0, 2, 3, 4
SPEC EF (p1.state = eating & EF (A [ p1.state = eating U (!(p1.state = eating) & EF (A [ !(p2.state = eating) U p1.state = eating ]))]))
SPEC EF (p1.state = eating & EF (A [ p1.state = eating U (!(p1.state = eating) & EF (A [ !(p3.state = eating) U p1.state = eating ]))]))
SPEC EF (p1.state = eating & EF (A [ p1.state = eating U (!(p1.state = eating) & EF (A [ !(p4.state = eating) U p1.state = eating ]))])) -- philosopher 1 can eat before philosopher 4
SPEC EF (p1.state = eating & EF (A [ p1.state = eating U (!(p1.state = eating) & EF (A [ !(p0.state = eating) U p1.state = eating ]))])) -- philosopher 1 can eat before philosopher 0

-- philosopher 2 can eat before philosopher 0, 1, 3, 4
SPEC EF (p2.state = eating & EF (A [ p2.state = eating U (!(p2.state = eating) & EF (A [ !(p3.state = eating) U p2.state = eating ]))]))
SPEC EF (p2.state = eating & EF (A [ p2.state = eating U (!(p2.state = eating) & EF (A [ !(p4.state = eating) U p2.state = eating ]))]))
SPEC EF (p2.state = eating & EF (A [ p2.state = eating U (!(p2.state = eating) & EF (A [ !(p0.state = eating) U p2.state = eating ]))]))
SPEC EF (p2.state = eating & EF (A [ p2.state = eating U (!(p2.state = eating) & EF (A [ !(p1.state = eating) U p2.state = eating ]))]))

-- philosopher 3 can eat before philosopher 0, 1, 2, 4
SPEC EF (p3.state = eating & EF (A [ p3.state = eating U (!(p3.state = eating) & EF (A [ !(p4.state = eating) U p3.state = eating ]))]))
SPEC EF (p3.state = eating & EF (A [ p3.state = eating U (!(p3.state = eating) & EF (A [ !(p0.state = eating) U p3.state = eating ]))]))
SPEC EF (p3.state = eating & EF (A [ p3.state = eating U (!(p3.state = eating) & EF (A [ !(p1.state = eating) U p3.state = eating ]))]))
SPEC EF (p3.state = eating & EF (A [ p3.state = eating U (!(p3.state = eating) & EF (A [ !(p2.state = eating) U p3.state = eating ]))]))

-- philosopher 4 can eat before philosopher 0, 1, 2, 3
SPEC EF (p4.state = eating & EF (A [ p4.state = eating U (!(p4.state = eating) & EF (A [ !(p0.state = eating) U p4.state = eating ]))]))
SPEC EF (p4.state = eating & EF (A [ p4.state = eating U (!(p4.state = eating) & EF (A [ !(p1.state = eating) U p4.state = eating ]))]))
SPEC EF (p4.state = eating & EF (A [ p4.state = eating U (!(p4.state = eating) & EF (A [ !(p2.state = eating) U p4.state = eating ]))]))
SPEC EF (p4.state = eating & EF (A [ p4.state = eating U (!(p4.state = eating) & EF (A [ !(p3.state = eating) U p4.state = eating ]))]))


    
MODULE philosopher(i,left,right)
  
VAR
  state : {thinking, hungry, eating, done};
  
DEFINE
  --
  -- These are just abbreviations, not state variables
  --
  gotleft := (left=i);
  gotright := (right=i);
  leftfree := (left=nobody);
  rightfree := (right=nobody);
    
ASSIGN
  init(state) := thinking;

  next(left)  := case
    (state = done) : nobody; -- drop chopstick
    --
    -- if hungry and both chopsticks are free, take left chopstick
    --
    ((state=hungry) & leftfree & (rightfree | gotright)) : i;
    TRUE : left;
  esac;

  next(right) := case
    (state = done) : nobody; -- drop chopstick
    --
    -- if hungry and both chopsticks are free, take right chopstick
    --
    ((state=hungry) & (leftfree | gotleft) & rightfree) : i; 
    TRUE : right;
  esac;

  next(state) := case
    (state=thinking) : {thinking, hungry};
    (state=hungry) & gotleft & gotright : eating;
    (state=hungry) : hungry; -- don't have chopsticks
    (state=eating) : {eating, done};
    (state=done) : thinking;
    TRUE : state;
  esac;

-- add fairness constraints here
FAIRNESS (running & leftfree & rightfree) -- every philosopher must get opportunities where eating is possible
FAIRNESS !(state = eating) -- every philosopher must think sometimes